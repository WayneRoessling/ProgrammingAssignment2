## The makeCacheMatrix and cacheSolve functions work together to enabling caching of 
## the inverse matrix.  Cacheing ensure the system does not recompute the matrix invers
## unnecessarily.
##
## Usage:
## > m4x4 <- matrix(c(21,1,3,2,2,26,1,9,9,1,11,2,2,3,9,16), nrow = 4, ncol = 4)
## > specialmatrix <- makeCacheMatrix(m4x4)
## > cacheSolve(specialmatrix)
## [,1]         [,2]         [,3]         [,4]
## [1,]  0.052641571 -0.009587221 -0.046037644  0.021113582
## [2,] -0.001084834  0.040898243 -0.001627251 -0.006617488
## [3,] -0.010441527  0.018645585  0.109337709 -0.063693317
## [4,] -0.004664786 -0.024137557 -0.006997179  0.071544804
## 

## makeCacheMatrix(matrix) function creates a special "matrix" object that can cache 
## its inverse.
##
## Methods:
##    makeCacheMatrix(matrix) : constructs the special matrix with the data passed in 
##                          the "makeCacheMatrix(data)" functiona call,  default data  
##                          is an empty matrix
##     specialmatrix$set(data) : sets the matrix data of the special matrix
##     specialmatrix$get() : returns the matrix data
##     specialmatrix$setinverse(matrix) : sets the special matrix inverse data
##                                        use cacheSolve to set this (see cacheSolve)
##     specialmatrix$getinverse(matrix) : gets the special matrix inverse data
##
## Usage:
## > m4x4 <- matrix(c(21,1,3,2,2,26,1,9,9,1,11,2,2,3,9,16), nrow = 4, ncol = 4)
## > specialmatrix <- makeCacheMatrix(m4x4)
## > specialmatrix$get()
## > specialmatrix$getinverse() 

makeCacheMatrix <- function(x = matrix()) {
    xinverse <- NULL
    set <- function(y) {
        x <<- y
        xinverse <<- NULL
    }
    get <- function() x
    setinverse <- function(y) xinverse <<- y
    getinverse <- function() xinverse
    list(set = set, get = get,
         setinverse = setinverse,
         getinverse = getinverse)
}


## cacheSolve(x, ...) computes the inverse of the special "matrix" returned by 
## makeCacheMatrix. If the inverse has already been calculated 
## (and the matrix has not changed), then the cachesolve retrieves the 
## inverse from the cache.
##
## NOTE: This function only accepts the "List" generated by makeCacheMatrix
##
## NOTE: This function assume the matrix is invertible 

cacheSolve <- function(x, ...) {
    inverse <- x$getinverse()
    if(!is.null(inverse)) {
        ## message("getting cached data")
        return(inverse)
    }
    data <- x$get()
    inverse <- solve(data, ...)
    x$setinverse(inverse)
    inverse
    ## Return a matrix that is the inverse of 'x'
}
